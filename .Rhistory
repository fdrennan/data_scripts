tt$time = as.character(Sys.time())
tt = tt %>% nest
tt$trump = 'trump'
mongoConn$insert(tt)
tt
trumpTweets
tt
mongoConn$insert(tt)
tt %>% unnest
tt %>% unnest %>% toJSON
tt %>% unnest %>% toJSON %>% fromJSON
a=tt %>% unnest %>% toJSON %>% fromJSON
mongoConn$insert(a)
tt$
mongoConn$insert(tt)
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 10")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$time = as.character(Sys.time())
mongoConn$insert(tt)
Encoding(tt) = 'latin'
Encoding(tt) = 'Latin'
?Encoding
Encoding(tt) = 'bytes'
Encoding(tt$text) = 'bytes'
mongoConn$insert(tt)
Encoding(tt$text) = 'TUF-8'
Encoding(tt$text) = 'UTF-8'
mongoConn$insert(tt)
tt %>% dim
tt %>% filter(
1:323 > 100
)
mongoConn$insert(tt %>% filter(
1:323 > 100
)
)
mongoConn$insert(tt %>% filter(
1:323 < 100
)
)
mongoConn$insert(tt %>% filter(
1:323 > 300
)
)
tt$text
tt$text[[1]]
mongoConn$insert(
tt$text[[1]]
)
tt$text
➡️
tt$text[316]
tt$text[316] %>% cat
tt$text
mongoConn$insert(tt[1:3,])
mongoConn$insert(tt[1:30,])
mongoConn$insert(tt[1:100,])
mongoConn$insert(tt[1:900,])
mongoConn$insert(tt[1:90,])
mongoConn$insert(tt[1:80,])
mongoConn$insert(tt[1:70,])
mongoConn$insert(tt[1:75,])
mongoConn$insert(tt[1:73,])
mongoConn$insert(tt[1:72,])
mongoConn$insert(tt[1:71,])
tt[71,]
sub("\\xed", "", tt$text
sub("\\xed", "", tt$text )
sub("\\xed", "", tt$text )
sub("\\xed", "", tt$text[71] )
rep("\\xed", "", tt$text[71] )
?sub
rep("\\xed", "", tt$text[71] )
sub("\\xed", "", tt$text[71] )
sub("\xed", "", tt$text[71] )
sub("\xed", "", tt$text[71] )
sub("\\xed", "", tt$text[71] )
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7", "", tt$text[71] )
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", tt$text[71] )
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\", "", tt$text[71] )
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed", "", tt$text[71] )
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed", "", tt$text[71] )
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", tt$text[71] )
tt$text[71]=sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", tt$text[71] )
mongoConn$insert(tt[1:71,])
mongoConn$insert(tt[1:100,])
mongoConn$insert(tt[1:300,])
mongoConn$insert(tt[1:200,])
mongoConn$insert(tt[1:150,])
mongoConn$insert(tt[1:170,])
mongoConn$insert(tt[1:180,])
mongoConn$insert(tt[1:175,])
mongoConn$insert(tt[1:172,])
mongoConn$insert(tt[1:173,])
mongoConn$insert(tt[1:174,])
mongoConn$insert(tt[1:175,])
tt$text[175]
tt$text %>%
lapply(
sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", . )
)
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
)
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
)
mongoConn$insert(tt)
tt
tt %>% nest()
tt = tt %>% nest
tt$trump = 'trump'
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 10")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$time = as.character(Sys.time())
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
)
tt = tt %>% nest
tt
tt %>% unnest()
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 10")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
tt = tt %>% nest
tt$time = as.character(Sys.time())
tt$trump = 'trump'
tt
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 10")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
tt = tt %>% nest
tt$time = as.character(Sys.time())
tt$trump = 'trump'
mongoConn$insert(tt)
tt
# insert to db.
mongoConn$insert(tt)
cat(.libPaths())
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 10")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
tt = tt %>% nest
tt$time = as.character(Sys.time())
tt$person = 'trump'
cat(.libPaths())
# insert to db.
mongoConn$insert(tt)
a = mongo_connect('tweets', 'twitter')
a$find('{"person": "trump"}')
a=a$find('{"person": "trump"}')
a %>% unnest(data)
a = a %>% unnest(data)
a$time
a %>% group_by(time)
a = a %>% group_by(time)
a$text
a
a = a %>% select(time, favoriteCount)
a
a %>% spread(time, a)
?spread
a %>% spread(ti, ad)
stocks <- data.frame(
time = as.Date('2009-01-01') + 0:9,
X = rnorm(10, 0, 1),
Y = rnorm(10, 0, 2),
Z = rnorm(10, 0, 4)
)
stocksm <- stocks %>% gather(stock, price, -time)
stocksm
stocksm %>% spread(time, price)
a
a %>% spread(time, favoritesCount())
a %>% spread(time, favoriteCount)
a %>% spread(time, favoriteCount)
a
a %>% ungroup %>% spread(time, favoriteCount)
a
a$time %>% unique
a %>% spread(time)
a %>% spread(favoriteCount, time)
a
a=a %>% group_by(time)
a
ls
a
a=a$find('{"person": "trump"}')
a = mongo_connect('tweets', 'twitter')
a=a$find('{"person": "trump"}')
a
a %>% as_tibble()
a=a %>% as_tibble()
a
a %>% unnest(data)
a=a %>% unnest(data)
a
a$text
a$text %>% as.vector()
a$text = a$text %>% as.vector()
a
a$text = a$text %>% unlist()
a
a$text
a
a$id[1]
a %>% filter(id == 954136290768846850)
a %>% filter(id == '954136290768846850')
a=a %>% filter(id == '954136290768846850')
a$text
a$favorited
a$retweetCount
