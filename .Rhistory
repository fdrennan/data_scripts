}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
tt = tt %>% nest
tt$time = as.character(Sys.time())
tt$trump = 'trump'
mongoConn$insert(tt)
tt
# insert to db.
mongoConn$insert(tt)
cat(.libPaths())
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 10")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongoConn <- mongo_connect('tweets', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
tt = tt %>% nest
tt$time = as.character(Sys.time())
tt$person = 'trump'
cat(.libPaths())
# insert to db.
mongoConn$insert(tt)
a = mongo_connect('tweets', 'twitter')
a$find('{"person": "trump"}')
a=a$find('{"person": "trump"}')
a %>% unnest(data)
a = a %>% unnest(data)
a$time
a %>% group_by(time)
a = a %>% group_by(time)
a$text
a
a = a %>% select(time, favoriteCount)
a
a %>% spread(time, a)
?spread
a %>% spread(ti, ad)
stocks <- data.frame(
time = as.Date('2009-01-01') + 0:9,
X = rnorm(10, 0, 1),
Y = rnorm(10, 0, 2),
Z = rnorm(10, 0, 4)
)
stocksm <- stocks %>% gather(stock, price, -time)
stocksm
stocksm %>% spread(time, price)
a
a %>% spread(time, favoritesCount())
a %>% spread(time, favoriteCount)
a %>% spread(time, favoriteCount)
a
a %>% ungroup %>% spread(time, favoriteCount)
a
a$time %>% unique
a %>% spread(time)
a %>% spread(favoriteCount, time)
a
a=a %>% group_by(time)
a
ls
a
a=a$find('{"person": "trump"}')
a = mongo_connect('tweets', 'twitter')
a=a$find('{"person": "trump"}')
a
a %>% as_tibble()
a=a %>% as_tibble()
a
a %>% unnest(data)
a=a %>% unnest(data)
a
a$text
a$text %>% as.vector()
a$text = a$text %>% as.vector()
a
a$text = a$text %>% unlist()
a
a$text
a
a$id[1]
a %>% filter(id == 954136290768846850)
a %>% filter(id == '954136290768846850')
a=a %>% filter(id == '954136290768846850')
a$text
a$favorited
a$retweetCount
tt$time = ISODate(as.character(Sys.time()))
ISOdate()
tt$time = ISOdate(as.character(Sys.time()))
ISOdate(as.character(Sys.time()))
tt$time = ISOdate(Sys.time())
ISOdate(Sys.time())
?ISOdate
library(lubridate)
make_datetime()
df <- data.frame(
dates = Sys.time() + 1:4
)
df
as.character(Sys.time())
tt$time = Sys.time()
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 1")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongo_connect <-
function(collectionName, dbName) {
# Cred
hostName = "mongodb://admin:thirdday1@18.218.94.116:27017"
m <- mongolite::mongo(collection = collectionName , db = dbName, url = hostName)
m
}
mongoConn <- mongo_connect('tweets_new', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
tt = tt %>% nest
tt$time = Sys.time()
tt$person = 'trump'
tt$`_id` = 'twitter_tweet'
# insert to db.
mongoConn$insert(tt)
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 1")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongo_connect <-
function(collectionName, dbName) {
# Cred
hostName = "mongodb://admin:thirdday1@18.218.94.116:27017"
m <- mongolite::mongo(collection = collectionName , db = dbName, url = hostName)
m
}
mongoConn <- mongo_connect('tweets_new', 'twitter')
ttt = tt
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
as.vector()
ttt = tt
ttt
tt = tt %>% nest
tt$time = Sys.time()
tt$person = 'trump'
tt$`_id` = 'twitter_tweet'
tt
tt %>% unnest(data)
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
unlist
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 1")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongo_connect <-
function(collectionName, dbName) {
# Cred
hostName = "mongodb://admin:thirdday1@18.218.94.116:27017"
m <- mongolite::mongo(collection = collectionName , db = dbName, url = hostName)
m
}
mongoConn <- mongo_connect('tweets_new', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
unlist
ttt = tt
ttt
tt = tt %>% nest
tt
tt$time = Sys.time()
tt$person = 'trump'
tt$`_id` = 'trump_tweets'
# insert to db.
mongoConn$insert(tt)
tt
tt %>% unnest(data)
tt %>% unnest(data) %>% View
library(RPostgreSQL)
library(twitteR)
library(stringr)
library(rvest)
library(lubridate)
library(drentools)
consumer_key <- "s4h5t47KxmlKiVRvqXLOzGiDG"
consumer_secret <- "7p3ulGMcFtSTbbvhMYavLklSReUbAJ6BSfZPZx1BXKGbE3XsWL"
access_token <- "273988968-ZWeALI3PklEaxIvOTCWoft95qBimpguNM6ib7FL0"
access_secret <- "d0mNClHjuS9WvbxSngWsSWz0ZAlBejSc3BijEfTaymuQG"
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
user_name <- "realDonaldTrump"
# Download tweets from user profile
tweets <- userTimeline(user_name, n = 500)
# Convert tweets to a data frame
trumpTweets <- twListToDF(tweets)
tt <- trumpTweets
trumpTweets$actual = NA
trumpTweets$links = NA
filtered = ymd_hms(trumpTweets$created) > (Sys.time() %>% ymd_hms) - hm("0, 1")
trumpTweets = trumpTweets[filtered,]
#
if(nrow(trumpTweets) != 0) {
for(i in 1:nrow(trumpTweets)) {
returnedValue <-
str_extract(trumpTweets$text[i], "https://.*")
if(!is.na(returnedValue)) {
returnedValue = strsplit(returnedValue, " ")[[1]]
returnedValue = returnedValue[length(returnedValue)]
returnedValue <-
returnedValue %>%
read_html() %>%
html_node('.tweet-text') %>%
as.character
trumpTweets$actual[i] <- returnedValue
}
print(i)
}
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv,
dbname = "freddydb",
host = "mydatabase.c2pc3qmfwusq.us-east-2.rds.amazonaws.com",
port = 5432,
user = "fdrennan",
password = 'thirdday1')
trumpTweets$time = as.character(Sys.time())
Encoding(trumpTweets$text) = 'byte'
# writes df to the PostgreSQL database "postgres", table "cartable"
dbWriteTable(con,
"trumpTweets",
value = trumpTweets,
append = TRUE,
row.names = FALSE)
}
mongo_connect <-
function(collectionName, dbName) {
# Cred
hostName = "mongodb://admin:thirdday1@18.218.94.116:27017"
m <- mongolite::mongo(collection = collectionName , db = dbName, url = hostName)
m
}
mongoConn <- mongo_connect('tweets_new', 'twitter')
tt$text <-
tt$text %>%
lapply(
function(x) sub("\xed\xa0\xbc\xed\xb7\xba\xed\xa0\xbc\xed\xb7\xb8", "", x )
) %>%
unlist
tt
tt$id
# tt = tt %>% nest
tt
# tt = tt %>% nest
tt %>%
group_by(id)
# tt = tt %>% nest
tt %>%
group_by(id) %>%
nest
